package YccStudio.WebCam;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.imageio.ImageIO;
import org.bytedeco.javacpp.opencv_core;
import org.bytedeco.javacpp.opencv_core.IplImage;
import org.bytedeco.javacv.FFmpegFrameGrabber;
import org.bytedeco.javacv.Frame;
import org.bytedeco.javacv.FrameGrabber.Exception;
import org.bytedeco.javacv.Java2DFrameConverter;
import org.bytedeco.javacv.OpenCVFrameConverter;

public class VideoImage {
    private static final String IMAGEMAT="png";
    private static final String ROTATE="rotate";

    //默認截取視頻的中間幀為封面
    public static final int MOD=2;

    public static void main(String[] args) throws Exception {
        System.out.println(randomGrabberFFmpegImage("C:/lyz/1522372294724_79583.mov", 2));
    }

    //獲取視頻縮略圖
    //filePath 視頻路徑
    //mod 視頻長度/mod獲取第幾幀
    public static String randomGrabberFFmpegImage(String filePath, int mod) throws Exception {
        String targetFilePath="";
        FFmpegFrameGrabber ff=FFmpegFrameGrabber.createDefault(filePath);
        ff.start();
        String rotate=ff.getVideoMetadata(ROTATE);
        int ffLength=ff.getLengthInFrames();
        Frame f;
        int i=0;
        int index=ffLength/mod;
        while(i<ffLength) {
            f=ff.grabImage();
            if(i==index) {
                if(null!=rotate&&rotate.length()>1) {
                    OpenCVFrameConverter.ToIplImage converter=new OpenCVFrameConverter.ToIplImage();
                    
                    org.bytedeco.opencv.opencv_core.IplImage src=converter.convert(f);                    
                    
                    f=converter.convert(rotate(src, Integer.valueOf(rotate)));
                    
                }
                targetFilePath=getImagePath(filePath, i);
                doExecuteFrame(f, targetFilePath);
                break;
            }
            i++;
        }
        ff.stop();
        return targetFilePath;
    }

    //根據視頻路徑生成縮略圖存放路徑
    //filePath 視頻路徑
    //index 第幾幀
    //回傳 縮略圖的存放路徑
    private static String getImagePath(String filePath, int index) {
        if(filePath.contains(".")&&filePath.lastIndexOf(".")<filePath.length()-1) {
            filePath=filePath.substring(0, filePath.lastIndexOf(".")).concat("_").concat(String.valueOf(index)).concat(".").concat(IMAGEMAT);
        }
        return filePath;
    }

    //旋轉圖片
    public static IplImage rotate(org.bytedeco.opencv.opencv_core.IplImage src, int angle) {
        IplImage img=IplImage.create(src.height(), src.width(), src.depth(), src.nChannels());
        opencv_core.cvTranspose(src, img);
        opencv_core.cvFlip(img, img, angle);
        return img;
    }

    //截取縮略圖
    //targerFilePath 封面圖片
    public static void doExecuteFrame(Frame f, String targerFilePath) {
        if(null==f||null==f.image) {
            return;
        }
        Java2DFrameConverter converter=new Java2DFrameConverter();
        BufferedImage bi=converter.getBufferedImage(f);
        File output=new File(targerFilePath);
        try {
            ImageIO.write(bi, IMAGEMAT, output);
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

    //根據視頻長度隨機生成隨機數集合
    //baseNum 基礎數字，此處為視頻長度
    //length 隨機數集合長度
    //回傳 隨機數集合
    public static List<Integer> random(int baseNum, int length) {
        List<Integer> list=new ArrayList<Integer>(length);
        while(list.size()<length) {
            Integer next=(int)(Math.random()*baseNum);
            if(list.contains(next)) {
                continue;
            }
            list.add(next);
        }
        Collections.sort(list);
        return list;
    }

}
