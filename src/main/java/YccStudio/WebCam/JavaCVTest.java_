package YccStudio.WebCam;

import java.io.File;
import java.net.MalformedURLException;
import java.util.concurrent.TimeUnit;

import javax.swing.WindowConstants;

import org.bytedeco.javacpp.opencv_core;
import org.bytedeco.javacpp.opencv_core.Mat;
import org.bytedeco.javacpp.opencv_imgproc;
import org.bytedeco.javacpp.opencv_objdetect;
import org.bytedeco.javacv.CanvasFrame;
import org.bytedeco.javacv.FFmpegFrameGrabber;
import org.bytedeco.javacv.Frame;
import org.bytedeco.javacv.FrameGrabber;
import org.bytedeco.javacv.IPCameraFrameGrabber;
import org.bytedeco.javacv.OpenCVFrameConverter;
import org.bytedeco.javacv.OpenCVFrameGrabber;
import org.bytedeco.javacv.VideoInputFrameGrabber;
import org.junit.Test;

public class JavaCVTest {

    private void showFrames(String winTitle, FrameGrabber grabber) throws FrameGrabber.Exception, InterruptedException {
	CanvasFrame canvas = new CanvasFrame(winTitle, 1);// 新建一個窗口
	canvas.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	canvas.setAlwaysOnTop(true);
	while (true) {
	    if (!canvas.isVisible()) {
		break;
	    }
	    Frame frame = grabber.grab();
	    canvas.showImage(frame);
	    Thread.sleep(50);// 50毫秒刷新一次圖像
	}
    }

    private void showFramesWithFace(String winTitle, FrameGrabber grabber)
	    throws FrameGrabber.Exception, InterruptedException {
	OpenCVFrameConverter.ToMat convertToMat = new OpenCVFrameConverter.ToMat();
	File fileAbsolutePath = new File(
		ClassLoader.getSystemClassLoader().getResource("data/lbpcascade_frontalface_improved.xml").getFile());
	// opencv_objdetect.CvHaarClassifierCascade
	// face_cascade=opencv_objdetect.cvLoadHaarClassifierCascade(fileAbsolutePath.getAbsolutePath(),new
	// opencv_core.CvSize(0,0));
	opencv_objdetect.CascadeClassifier face_cascade = new opencv_objdetect.CascadeClassifier(
		fileAbsolutePath.getAbsolutePath());
	opencv_core.RectVector faces = new opencv_core.RectVector();
	CanvasFrame canvas = new CanvasFrame(winTitle, 1);// 新建一個窗口
	canvas.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	canvas.setAlwaysOnTop(true);
	while (true) {
	    if (!canvas.isVisible()) {
		break;
	    }
	    Frame frame = grabber.grab();
	    org.bytedeco.opencv.opencv_core.Mat mat=convertToMat.convert(frame);
	    if (mat.empty())
		continue;
	    Mat videoMatGray = new Mat();
	    
	    opencv_imgproc.cvtColor(mat, videoMatGray, org.bytedeco.javacpp.opencv_imgproc.COLOR_BGRA2GRAY);
	    opencv_imgproc.equalizeHist(videoMatGray, videoMatGray);
	    // int[] rejectLevels = new int[0];
	    // double[] levelWeights = new double[0];
	    face_cascade.detectMultiScale(videoMatGray, faces);
	    for (int i = 0; i < faces.size(); i++) {
		opencv_core.Rect face = faces.get(i);
		opencv_imgproc.rectangle(mat, face, opencv_core.Scalar.RED, 4, 8, 0);
	    }

	    // opencv_highgui.imshow(winTitle, mat);
	    // opencv_highgui.waitKey(30);
	    canvas.showImage(convertToMat.convert(mat));
	    Thread.sleep(30);// 50毫秒刷新一次圖像
	}
    }

    @Test
    public void testCamera() throws InterruptedException, FrameGrabber.Exception {
	OpenCVFrameGrabber grabber = new OpenCVFrameGrabber(0);
	grabber.setImageWidth(1280);
	grabber.setImageHeight(720);
	grabber.start(); // 開始獲取攝像頭數據
	showFrames("Camera", grabber);
	grabber.stop();
	grabber.close();
    }

    @Test
    public void testCamera1() throws FrameGrabber.Exception, InterruptedException {
	VideoInputFrameGrabber grabber = new VideoInputFrameGrabber(0);
	grabber.start(); // 開始獲取攝像頭數據
	showFrames("Camera", grabber);
	grabber.stop();
	grabber.close();
    }

    @Test
    public void testCamera2() throws FrameGrabber.Exception, InterruptedException, MalformedURLException {
	IPCameraFrameGrabber grabber = new IPCameraFrameGrabber(
		"http://admin:12345@192.0.0.64:554/MPEG-4/ch1/main/av_stream", 30, 30, TimeUnit.SECONDS);
	grabber.start();
	showFrames("IPCamera", grabber);
	grabber.stop();
	grabber.close();
    }

    @Test
    public void testVideo() throws FrameGrabber.Exception, InterruptedException, MalformedURLException {
	FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault("rtmp://127.0.0.1:12580/live/app"); // 這里也可以是本地文件，也可以網絡文件。如：rtmp://127.0.0.1:12580/live/app
	grabber.setImageWidth(1366);
	grabber.setImageHeight(768);
	grabber.start();
	showFrames("Video", grabber);
	grabber.stop();
	grabber.close();
    }

    @Test
    public void testFaceRecognize()
	    throws FrameGrabber.Exception, InterruptedException, MalformedURLException, FrameRecorder.Exception {
	OpenCVFrameGrabber grabber = OpenCVFrameGrabber.createDefault(0);
	grabber.start();
	showFramesWithFace("Video", grabber);
	grabber.stop();
	grabber.close();
    }

    @Test
    public void testRecordCamera()
	    throws FrameGrabber.Exception, InterruptedException, MalformedURLException, FrameRecorder.Exception {
	// Preload the opencv_objdetect module to work around a known bug.
	String str = Loader.load(opencv_objdetect.class);
	System.out.println(str);

	FrameGrabber grabber = FrameGrabber.createDefault(0);
	grabber.start();
	OpenCVFrameConverter.ToIplImage converter = new OpenCVFrameConverter.ToIplImage();// 轉換器
	opencv_core.IplImage grabbedImage = converter.convert(grabber.grab());// 抓取一幀視頻並將其轉換為圖像，至於用這個圖像用來做什么？加水印，人臉識別等等自行添加
	int width = grabbedImage.width();
	int height = grabbedImage.height();

	// String outputFile = "d:\\record.mp4";
	String outputFile = "rtmp://127.0.0.1:12580/live/mycamera";
	FrameRecorder recorder = FrameRecorder.createDefault(outputFile, width, height); // org.bytedeco.javacv.FFmpegFrameRecorder
	System.out.println(recorder.getClass().getName());// org.bytedeco.javacv.FFmpegFrameRecorder
	recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);// avcodec.AV_CODEC_ID_H264，編碼
	recorder.setFormat("flv");// 封裝格式，如果是推送到rtmp就必須是flv封裝格式
	recorder.setFrameRate(25);
	recorder.start();// 開啟錄制器
	long startTime = 0;
	long videoTS;
	CanvasFrame frame = new CanvasFrame("camera", CanvasFrame.getDefaultGamma() / grabber.getGamma()); // 2.2/2.2=1
	// frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	frame.setAlwaysOnTop(true);
	Frame rotatedFrame;
	while (frame.isVisible() && (grabbedImage = converter.convert(grabber.grab())) != null) {
	    rotatedFrame = converter.convert(grabbedImage);
	    frame.showImage(rotatedFrame);
	    if (startTime == 0) {
		startTime = System.currentTimeMillis();
	    }
	    videoTS = (System.currentTimeMillis() - startTime) * 1000;// 這里要注意，注意位
	    System.out.println();
	    recorder.setTimestamp(videoTS);
	    recorder.record(rotatedFrame);
	    Thread.sleep(40);
	}
	recorder.stop();
	recorder.release();
	frame.dispose();
	grabber.stop();
	grabber.close();
    }
}
